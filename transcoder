#!/usr/bin/env python3
import os
import sys
import subprocess
import argparse
import logging
import json
from pathlib import Path
from datetime import datetime

# Setup logging to both file and console


def setup_logging():
    log_file = f"transcode_log_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"

    # We'll use two separate loggers - one for console (with no filenames) and one for file (with all details)

    # File logger (with all details)
    file_logger = logging.getLogger("file_logger")
    file_logger.setLevel(logging.INFO)

    # Console logger (generic info only)
    console_logger = logging.getLogger("console_logger")
    console_logger.setLevel(logging.INFO)

    # Create file handler with full details
    file_handler = logging.FileHandler(log_file)
    file_handler.setLevel(logging.INFO)
    file_formatter = logging.Formatter(
        '%(asctime)s - %(levelname)s - %(message)s')
    file_handler.setFormatter(file_formatter)
    file_logger.addHandler(file_handler)

    # Create console handler
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.INFO)
    console_formatter = logging.Formatter(
        '%(asctime)s - %(levelname)s - %(message)s')
    console_handler.setFormatter(console_formatter)
    console_logger.addHandler(console_handler)

    # We'll return both loggers
    return file_logger, console_logger, log_file

# Get video file metadata using ffprobe


def get_video_metadata(video_path, file_logger):
    try:
        cmd = [
            "ffprobe",
            "-v", "quiet",
            "-print_format", "json",
            "-show_format",
            "-show_streams",
            video_path
        ]
        result = subprocess.run(
            cmd, capture_output=True, text=True, check=True)
        return json.loads(result.stdout)
    except (subprocess.CalledProcessError, json.JSONDecodeError) as e:
        file_logger.warning(
            f"Failed to get metadata for {video_path}: {str(e)}")
        return None

# Extract video duration from metadata


def get_duration(metadata):
    if not metadata:
        return None

    # Try to get duration from format section
    if "format" in metadata and "duration" in metadata["format"]:
        try:
            return float(metadata["format"]["duration"])
        except (ValueError, TypeError):
            pass

    # If not found in format, try streams
    for stream in metadata.get("streams", []):
        if "duration" in stream:
            try:
                return float(stream["duration"])
            except (ValueError, TypeError):
                pass

    return None

# Convert HH:MM:SS.MS time format to seconds


def time_to_seconds(time_str):
    try:
        # Handle different time formats
        if '.' in time_str:  # Has milliseconds
            parts = time_str.split(':')
            if len(parts) == 3:  # HH:MM:SS.MS
                hours, minutes, seconds = parts
                seconds = float(seconds)
                return int(hours) * 3600 + int(minutes) * 60 + seconds
            elif len(parts) == 2:  # MM:SS.MS
                minutes, seconds = parts
                seconds = float(seconds)
                return int(minutes) * 60 + seconds
        else:  # No milliseconds
            parts = time_str.split(':')
            if len(parts) == 3:  # HH:MM:SS
                hours, minutes, seconds = parts
                return int(hours) * 3600 + int(minutes) * 60 + int(seconds)
            elif len(parts) == 2:  # MM:SS
                minutes, seconds = parts
                return int(minutes) * 60 + int(seconds)

        # If none of the above formats match, try direct conversion
        return float(time_str)
    except (ValueError, TypeError):
        return 0  # Return 0 on error

# Function to extract video resolution from metadata


def get_resolution(metadata):
    if not metadata:
        return "unknown", "unknown"

    for stream in metadata.get("streams", []):
        if stream.get("codec_type") == "video":
            return stream.get("width", "unknown"), stream.get("height", "unknown")

    return "unknown", "unknown"

# Find all video files in a directory and its subdirectories


def find_video_files(input_dir):
    video_extensions = ['.mp4', '.avi', '.mkv', '.mov',
                        '.wmv', '.flv', '.webm', '.m4v', '.3gp']
    video_files = []

    for root, _, files in os.walk(input_dir):
        for file in files:
            if any(file.lower().endswith(ext) for ext in video_extensions):
                # Use Path for better handling of special characters
                video_path = Path(root) / file
                video_files.append(str(video_path))

    return video_files

# Transcode a video file


def transcode_video(input_file, output_file, index, total, file_logger, console_logger):
    # Log with filename to file only
    file_logger.info(
        f"Starting transcoding of file #{index}/{total}: {os.path.basename(input_file)}")
    # Log to console without filename
    console_logger.info(f"[{index}/{total}] ▶️ Starting transcoding")
    print(f"[{index}/{total}] ▶️ Starting transcoding")

    try:
        # Get original metadata and file size
        original_size = os.path.getsize(input_file)
        metadata = get_video_metadata(input_file, file_logger)
        orig_width, orig_height = get_resolution(metadata)

        # Log original video details for diagnostics
        file_logger.info(
            f"Original video resolution: {orig_width}x{orig_height}")
        file_logger.info(
            f"Original video size: {original_size/1024/1024:.2f} MB")
        print(
            f"    Resolution: {orig_width}x{orig_height}, Size: {original_size/1024/1024:.2f} MB")

        # Use Path objects for better handling of special characters
        input_path = Path(input_file)
        output_path = Path(output_file)

        # Construct the ffmpeg command with all the requested tweaks
        cmd = [
            "ffmpeg",
            "-hwaccel", "auto",  # Add hardware acceleration where available
            "-i", str(input_path),
            "-map", "0:v:0", "-map", "0:a:0?",
            "-c:v", "libx265",
            "-preset", "slower",  # Changed from veryslow to slower
            # Enhanced x265 parameters
            "-x265-params", "limit-refs=3:no-amp=1:rd=4:aq-mode=2:bframes=4",
            "-crf", "28",
            "-g", "48",  # Keyframe every 2 seconds at 24fps - better mobile seeking
            # Only downscale if resolution is higher than 720p
            "-vf", "scale='min(1280,iw)':'min(720,ih)':force_original_aspect_ratio=decrease,setsar=1",
            "-r", "24",
            "-c:a", "aac",
            "-b:a", "48k",  # Reduced from 64k - sufficient for dialogue
            "-ac", "1",
            "-ar", "32000",  # Reduced from 44100 - sufficient for dialogue
            # Audio normalization and voice optimization
            "-af", "loudnorm,bandpass=f=1500:width_type=h:width=200",
            "-pix_fmt", "yuv420p",
            "-profile:v", "main", "-level", "3.1",
            "-movflags", "+faststart",
            "-metadata", "title=", "-metadata", "comment=",
            "-threads", "0",  # Use all available CPU cores
            "-v", "warning",  # Reduce verbosity - only show warnings and errors
            str(output_path)
        ]

        # Log the ffmpeg command for diagnostics (without the actual filename)
        cmd_log = ' '.join(cmd)
        cmd_log = cmd_log.replace(str(input_path), "INPUT_FILE").replace(
            str(output_path), "OUTPUT_FILE")
        file_logger.info(f"Running ffmpeg command: {cmd_log}")

        # Run the ffmpeg command
        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            bufsize=1
        )

        # Collect all error output for diagnostics
        error_lines = []
        last_progress = None

        # Process stderr to capture progress
        for line in process.stderr:
            error_lines.append(line)

            # Print progress updates when they contain frame information
            if "frame=" in line and "time=" in line:
                # Extract key progress info
                progress_info = {}
                for part in line.strip().split():
                    if "=" in part:
                        key, value = part.split("=", 1)
                        progress_info[key] = value

                # Extract the most important info
                frame = progress_info.get("frame", "?")
                time = progress_info.get("time", "?")
                fps = progress_info.get("fps", "?")
                speed = progress_info.get("speed", "?")

                # Create a concise progress message
                progress_msg = f"[{index}/{total}] Frame: {frame}, Time: {time}, FPS: {fps}, Speed: {speed}"

                # Update the line in place
                print(f"\r{progress_msg}", end="")
                last_progress = progress_msg

        # Wait for process to complete
        process.wait()
        if last_progress:
            print()  # Add a newline after the progress display

        if process.returncode != 0:
            # Log the error output to help diagnose the problem
            file_logger.error(
                f"Transcoding failed for file #{index}: {os.path.basename(input_file)}")
            file_logger.error("FFmpeg error output:")
            for line in error_lines:
                file_logger.error(f"  {line.strip()}")

            # Log sanitized error message to console
            console_logger.error(f"[{index}/{total}] ❌ Transcoding failed")
            print(f"[{index}/{total}] ❌ Transcoding failed")

            # Show a few of the last error lines (sanitized)
            if error_lines:
                error_preview = []
                for line in error_lines[-5:]:
                    # Skip progress lines in error summary
                    if "frame=" in line and "time=" in line:
                        continue
                    # Sanitize the error message to remove any filenames
                    sanitized = line.strip()
                    if input_file in sanitized:
                        sanitized = sanitized.replace(
                            os.path.basename(input_file), "INPUT_FILE")
                    if output_file in sanitized:
                        sanitized = sanitized.replace(
                            os.path.basename(output_file), "OUTPUT_FILE")
                    error_preview.append(sanitized)

                if error_preview:
                    print("    Error details:")
                    for line in error_preview:
                        print(f"    {line}")

            return False

        # Get new file size and calculate savings
        new_size = os.path.getsize(output_file)
        savings_bytes = original_size - new_size
        savings_percent = (savings_bytes / original_size) * \
            100 if original_size > 0 else 0

        # Get new metadata
        new_metadata = get_video_metadata(output_file, file_logger)
        new_width, new_height = get_resolution(new_metadata)

        # Log the results (full file name in log file only)
        file_logger.info(
            f"Completed file #{index}/{total}: {os.path.basename(input_file)}")
        file_logger.info(
            f"  Original resolution: {orig_width}x{orig_height}, New resolution: {new_width}x{new_height}")
        file_logger.info(
            f"  Original size: {original_size/1024/1024:.2f} MB, New size: {new_size/1024/1024:.2f} MB")
        file_logger.info(
            f"  Space saved: {savings_bytes/1024/1024:.2f} MB ({savings_percent:.2f}%)")

        # Console output (without filename)
        console_logger.info(f"[{index}/{total}] ✅ Transcoding completed")
        print(f"[{index}/{total}] ✅ Transcoding completed")
        print(
            f"    Original: {orig_width}x{orig_height}, {original_size/1024/1024:.2f} MB")
        print(
            f"    New: {new_width}x{new_height}, {new_size/1024/1024:.2f} MB")
        print(
            f"    Saved: {savings_bytes/1024/1024:.2f} MB ({savings_percent:.2f}%)")

        return True

    except Exception as e:
        # Log error with filename to file only
        file_logger.error(
            f"Error transcoding file #{index}: {os.path.basename(input_file)} - {str(e)}")
        # Log error to console without filename
        console_logger.error(f"[{index}/{total}] ❌ Error: {str(e)}")
        print(f"[{index}/{total}] ❌ Error: {str(e)}")
        return False


def main():
    # Parse command line arguments
    parser = argparse.ArgumentParser(description="Video Transcoder Script")
    parser.add_argument(
        "input_dir", help="Input directory containing video files to transcode")
    parser.add_argument("-s", "--success_dir",
                        help="Output directory for successfully transcoded files", default="transcoded_success")
    parser.add_argument(
        "-e", "--error_dir", help="Output directory for files that failed transcoding", default="transcoded_error")
    args = parser.parse_args()

    # Setup logging
    file_logger, console_logger, log_file = setup_logging()

    # Check if input directory exists
    if not os.path.isdir(args.input_dir):
        file_logger.error(f"Input directory does not exist: {args.input_dir}")
        console_logger.error(
            f"Input directory does not exist: {args.input_dir}")
        sys.exit(1)

    # Create output directories if they don't exist
    success_dir = Path(args.success_dir)
    error_dir = Path(args.error_dir)
    success_dir.mkdir(exist_ok=True)
    error_dir.mkdir(exist_ok=True)

    # Files to track successful and failed transcodes
    success_list_file = "successful_transcodes.txt"
    failed_list_file = "failed_transcodes.txt"
    successful_files = []
    failed_files = []

    # Find all video files in the input directory
    file_logger.info(f"Searching for video files in {args.input_dir}")
    console_logger.info(f"Searching for video files in {args.input_dir}")
    video_files = find_video_files(args.input_dir)

    if not video_files:
        file_logger.warning("No video files found.")
        console_logger.warning("No video files found.")
        print("❌ No video files found in the specified directory.")
        sys.exit(0)

    file_logger.info(f"Found {len(video_files)} video files to transcode")
    file_logger.info(f"Log file: {log_file}")
    console_logger.info(f"Found {len(video_files)} video files to transcode")
    console_logger.info(f"Log file: {log_file}")

    print(f"📁 Found {len(video_files)} video files to transcode")
    print(f"📝 Log file: {log_file}")
    print(f"✅ Success directory: {success_dir}")
    print(f"❌ Error directory: {error_dir}")
    print("-" * 50)

    # Transcode each video file
    successful = 0
    failed = 0
    total_original_size = 0
    total_new_size = 0

    for i, video_file in enumerate(video_files, 1):
        # Create output filename (flat structure)
        basename = os.path.basename(video_file)
        output_file = success_dir / basename
        error_output_file = error_dir / basename

        # Get original size for total calculation
        try:
            original_size = os.path.getsize(video_file)
            total_original_size += original_size
        except Exception as e:
            file_logger.error(
                f"Could not get file size for {video_file}: {str(e)}")
            print(f"[{i}/{len(video_files)}] ⚠️ Warning: Could not get file size")
            original_size = 0

        # Transcode the video
        if transcode_video(video_file, str(output_file), i, len(video_files), file_logger, console_logger):
            successful += 1
            successful_files.append(basename)
            try:
                new_size = os.path.getsize(output_file)
                total_new_size += new_size
            except Exception as e:
                file_logger.error(
                    f"Could not get output file size for {output_file}: {str(e)}")
        else:
            failed += 1
            failed_files.append(basename)
            # Copy the original file to the error directory
            try:
                # Using with blocks for safe file handling
                with open(video_file, 'rb') as src:
                    with open(error_output_file, 'wb') as dst:
                        dst.write(src.read())
                file_logger.info(
                    f"Copied original file to error directory: {basename}")
                console_logger.info(f"Copied file #{i} to error directory")
                print(
                    f"[{i}/{len(video_files)}] 📋 Copied original file to error directory")
            except Exception as e:
                file_logger.error(
                    f"Failed to copy file to error directory: {basename} - {str(e)}")
                console_logger.error(
                    f"Failed to copy file #{i} to error directory")
                print(
                    f"[{i}/{len(video_files)}] ❌ Failed to copy file to error directory: {str(e)}")

        print("-" * 50)  # Add separator between files

    # Write successful and failed files to their respective lists
    try:
        with open(success_list_file, 'w', encoding='utf-8') as f:
            f.write('\n'.join(successful_files))
        file_logger.info(
            f"Wrote list of {len(successful_files)} successful files to {success_list_file}")
        console_logger.info(
            f"Wrote list of {successful} successful files to file")
        print(
            f"📝 Wrote list of {successful} successful files to {success_list_file}")
    except Exception as e:
        file_logger.error(f"Failed to write successful files list: {str(e)}")
        console_logger.error("Failed to write successful files list")
        print(f"❌ Failed to write successful files list: {str(e)}")

    try:
        with open(failed_list_file, 'w', encoding='utf-8') as f:
            f.write('\n'.join(failed_files))
        file_logger.info(
            f"Wrote list of {len(failed_files)} failed files to {failed_list_file}")
        console_logger.info(f"Wrote list of {failed} failed files to file")
        print(f"📝 Wrote list of {failed} failed files to {failed_list_file}")
    except Exception as e:
        file_logger.error(f"Failed to write failed files list: {str(e)}")
        console_logger.error("Failed to write failed files list")
        print(f"❌ Failed to write failed files list: {str(e)}")

    # Calculate total savings
    total_savings = total_original_size - total_new_size
    savings_percent = (total_savings / total_original_size) * \
        100 if total_original_size > 0 else 0

    # Print summary with some visual enhancements
    print("\n" + "=" * 50)
    print(f"📊 SUMMARY")
    print("=" * 50)
    print(f"✅ Successfully transcoded: {successful} files")
    print(f"❌ Failed to transcode: {failed} files")
    print(f"💾 Total original size: {total_original_size/1024/1024:.2f} MB")
    print(f"💾 Total new size: {total_new_size/1024/1024:.2f} MB")
    print(
        f"🔽 Total space saved: {total_savings/1024/1024:.2f} MB ({savings_percent:.2f}%)")
    print(f"📝 Log file: {log_file}")
    print(f"📋 Successful files list: {success_list_file}")
    print(f"📋 Failed files list: {failed_list_file}")
    print("=" * 50)

    # Also log the summary details
    file_logger.info(
        f"Transcoding completed. {successful} successful, {failed} failed.")
    file_logger.info(
        f"Total original size: {total_original_size/1024/1024:.2f} MB")
    file_logger.info(f"Total new size: {total_new_size/1024/1024:.2f} MB")
    file_logger.info(
        f"Total space saved: {total_savings/1024/1024:.2f} MB ({savings_percent:.2f}%)")
    file_logger.info(f"Successful files list: {success_list_file}")
    file_logger.info(f"Failed files list: {failed_list_file}")


if __name__ == "__main__":
    main()
