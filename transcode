#!/usr/bin/env python3
"""
Video Transcoder Script
Transcodes video files using ffmpeg with H.265/HEVC encoding optimized for small file size.

Usage: python3 transcode.py [input_directory] [options]
"""

import os
import sys
import subprocess
import argparse
import logging
import json
import time
import shutil
import tempfile
from pathlib import Path
from datetime import datetime
from typing import Tuple, List, Dict, Optional

# Constants
VIDEO_EXTENSIONS = ['.mp4', '.avi', '.mkv', '.mov',
                    '.wmv', '.flv', '.webm', '.m4v', '.3gp']
MIN_FILE_SIZE = 1000  # 1KB minimum for valid video
MIN_OUTPUT_SIZE = 10000  # 10KB minimum for valid output

# ANSI color codes


class Colors:
    RESET = "\033[0m"
    BOLD = "\033[1m"
    RED = "\033[91m"
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    BLUE = "\033[94m"
    MAGENTA = "\033[95m"
    CYAN = "\033[96m"
    GREY = "\033[90m"


def supports_color() -> bool:
    """Check if terminal supports colors."""
    return hasattr(sys.stdout, 'isatty') and sys.stdout.isatty() and os.name != 'nt'


USE_COLORS = supports_color()


def colorize(text: str, color: str) -> str:
    """Add color to text if supported."""
    return f"{color}{text}{Colors.RESET}" if USE_COLORS else text


def setup_logging(log_dir: Path = Path('.')) -> Tuple[logging.Logger, logging.Logger, str]:
    """Set up file and console loggers."""
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    log_file = log_dir / f"transcode_log_{timestamp}.log"

    # File logger with full details
    file_logger = logging.getLogger("file_logger")
    file_logger.setLevel(logging.DEBUG)
    file_handler = logging.FileHandler(log_file)
    file_handler.setFormatter(logging.Formatter(
        '%(asctime)s - %(levelname)s - %(message)s'))
    file_logger.addHandler(file_handler)

    # Console logger without file paths
    console_logger = logging.getLogger("console_logger")
    console_logger.setLevel(logging.INFO)
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(logging.Formatter(
        '%(asctime)s - %(levelname)s - %(message)s'))
    console_logger.addHandler(console_handler)

    return file_logger, console_logger, str(log_file)


def human_size(bytes: int) -> str:
    """Convert bytes to human readable format."""
    for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
        if bytes < 1024.0:
            return f"{bytes:.2f} {unit}"
        bytes /= 1024.0
    return f"{bytes:.2f} PB"


def find_video_files(input_dir: Path) -> Tuple[List[Path], List[Path]]:
    """Find all video files and empty directories."""
    video_files = []
    all_dirs = set()
    dirs_with_videos = set()

    for root, dirs, files in os.walk(input_dir):
        root_path = Path(root)
        all_dirs.add(root_path)

        # Check for video files
        video_found = False
        for file in files:
            if any(file.lower().endswith(ext) for ext in VIDEO_EXTENSIONS):
                video_files.append(root_path / file)
                video_found = True

        if video_found:
            # Mark this directory and all parents as having videos
            current = root_path
            while current != input_dir.parent:
                dirs_with_videos.add(current)
                current = current.parent

    empty_dirs = sorted(all_dirs - dirs_with_videos)
    return video_files, empty_dirs


def get_video_metadata(video_path: Path) -> Optional[Dict]:
    """Get video metadata using ffprobe."""
    try:
        cmd = [
            "ffprobe", "-v", "quiet", "-print_format", "json",
            "-show_format", "-show_streams", str(video_path)
        ]
        result = subprocess.run(
            cmd, capture_output=True, text=True, timeout=30)
        if result.returncode == 0:
            return json.loads(result.stdout)
    except (subprocess.SubprocessError, json.JSONDecodeError, subprocess.TimeoutExpired):
        pass
    return None


def extract_video_info(metadata: Optional[Dict]) -> Dict:
    """Extract relevant information from video metadata."""
    info = {
        "duration": 0,
        "width": "unknown",
        "height": "unknown",
        "bitrate": "unknown",
        "codec": "unknown",
        "audio": {"codec": "none", "channels": "none", "bitrate": "none"}
    }

    if not metadata:
        return info

    # Duration
    if "format" in metadata and "duration" in metadata["format"]:
        try:
            info["duration"] = float(metadata["format"]["duration"])
        except (ValueError, TypeError):
            pass

    # Video stream info
    for stream in metadata.get("streams", []):
        if stream.get("codec_type") == "video":
            info["width"] = stream.get("width", "unknown")
            info["height"] = stream.get("height", "unknown")
            info["codec"] = stream.get("codec_name", "unknown")
            if "bit_rate" in stream:
                try:
                    info["bitrate"] = int(stream["bit_rate"])
                except (ValueError, TypeError):
                    pass
        elif stream.get("codec_type") == "audio":
            info["audio"] = {
                "codec": stream.get("codec_name", "unknown"),
                "channels": stream.get("channels", "unknown"),
                "bitrate": stream.get("bit_rate", "unknown")
            }

    # Fallback bitrate from format
    if info["bitrate"] == "unknown" and "format" in metadata and "bit_rate" in metadata["format"]:
        try:
            info["bitrate"] = int(metadata["format"]["bit_rate"])
        except (ValueError, TypeError):
            pass

    return info


def verify_input_file(file_path: Path, file_logger: logging.Logger) -> Tuple[bool, Optional[str]]:
    """Verify input file is valid."""
    if not file_path.exists():
        return False, "File does not exist"

    if not os.access(file_path, os.R_OK):
        return False, "File is not readable"

    try:
        file_size = file_path.stat().st_size
        if file_size < MIN_FILE_SIZE:
            return False, f"File too small ({file_size} bytes)"
    except OSError as e:
        return False, f"Cannot access file: {e}"

    # Verify it's a valid video
    metadata = get_video_metadata(file_path)
    if metadata:
        for stream in metadata.get("streams", []):
            if stream.get("codec_type") == "video":
                return True, None

    return False, "No video stream found"


def create_ffmpeg_command(input_path: Path, output_path: Path) -> List[str]:
    """Create the ffmpeg encoding command."""
    return [
        "ffmpeg", "-y",
        "-i", str(input_path),
        "-map", "0:v:0", "-map", "0:a:0?",
        "-c:v", "libx265",
        "-preset", "slower",
        "-x265-params", "limit-refs=3:no-amp=1:rd=4:aq-mode=3:bframes=5:psy-rd=1.0:psy-rdoq=2.0",
        "-crf", "25",
        "-g", "96",
        "-vf", "scale='min(1920,iw)':'min(1080,ih)':force_original_aspect_ratio=decrease,setsar=1:1",
        "-c:a", "aac",
        "-b:a", "64k",
        "-ac", "1",
        "-ar", "44100",
        "-pix_fmt", "yuv420p",
        "-profile:v", "main", "-level", "4.1",
        "-movflags", "+faststart",
        "-metadata", "title=", "-metadata", "comment=",
        "-threads", "0",
        "-v", "warning",
        str(output_path)
    ]


def monitor_progress(process: subprocess.Popen, duration: float, index: int, total: int,
                     output_path: Path) -> Tuple[int, bool, str]:
    """Monitor ffmpeg progress and display updates."""
    start_time = time.time()
    last_update = start_time
    term_width = shutil.get_terminal_size().columns

    # Initial message
    print(f"\r[{index}/{total}] Starting encoding...", end="", flush=True)

    while process.poll() is None:
        time.sleep(0.1)
        current_time = time.time()
        elapsed = current_time - start_time

        # Update display every second
        if (current_time - last_update) >= 1.0:
            last_update = current_time

            # Check output file
            file_size = 0
            file_status = "waiting..."
            if output_path.exists():
                try:
                    file_size = output_path.stat().st_size
                    file_status = f"output: {human_size(file_size)}"
                except OSError:
                    pass

            # Calculate progress
            if duration > 0:
                progress = min(95, (elapsed / (duration * 1.5)) * 100)
                bar_length = min(20, term_width - 80)
                filled = int(bar_length * progress / 100)

                # Color based on progress
                if progress < 33:
                    bar_color = Colors.RED
                elif progress < 66:
                    bar_color = Colors.YELLOW
                else:
                    bar_color = Colors.GREEN

                bar = colorize('‚ñà' * filled, bar_color) + \
                    colorize('‚ñë' * (bar_length - filled), Colors.GREY)

                # ETA calculation
                eta_str = ""
                if progress > 0:
                    eta_seconds = (elapsed / progress * 100) - elapsed
                    eta_str = f" | ETA: {int(eta_seconds/60)}m {int(eta_seconds % 60)}s"

                # Format display
                elapsed_str = f"{int(elapsed/60)}m {int(elapsed % 60)}s"
                progress_msg = f"[{index}/{total}] [{bar}] {progress:.1f}% | {elapsed_str} [{file_status}]{eta_str}"
            else:
                # No duration info
                elapsed_str = f"{int(elapsed/60)}m {int(elapsed % 60)}s"
                progress_msg = f"[{index}/{total}] Processing... {elapsed_str} [{file_status}]"

            print(f"\r{progress_msg:<{term_width-1}}", end="", flush=True)

    # Get final status
    returncode = process.returncode
    file_created = output_path.exists() and output_path.stat().st_size > MIN_OUTPUT_SIZE

    # Get error output if available
    error_output = ""
    if hasattr(process, 'stderr'):
        try:
            _, stderr = process.communicate(timeout=1)
            error_output = stderr if stderr else ""
        except:
            pass

    # Final message
    total_time = time.time() - start_time
    final_msg = f"[{index}/{total}] Encoding completed in {int(total_time/60)}m {int(total_time % 60)}s"
    if file_created:
        final_size = output_path.stat().st_size
        final_msg += f" [{human_size(final_size)}]"
    print(f"\r{colorize(final_msg, Colors.GREEN if file_created else Colors.RED):<{term_width-1}}")

    return returncode, file_created, error_output


def print_transcoding_summary(index: int, total: int, original_info: Dict,
                              original_size: int, new_size: int, is_larger: bool):
    """Print detailed transcoding summary."""
    print("\n" + "‚îÄ" * 50)
    print(colorize("    TRANSCODING SUMMARY", Colors.BOLD + Colors.CYAN))
    print("‚îÄ" * 50)

    print(f"    File: {colorize(f'#{index}', Colors.BOLD)} of {total}")

    # Before/After comparison
    print(
        f"\n    {colorize('BEFORE:', Colors.YELLOW):<25} {colorize('AFTER:', Colors.GREEN)}")
    print(
        f"    Resolution:  {original_info['width']}x{original_info['height']}")

    if original_info['bitrate'] != 'unknown':
        print(f"    Bitrate:     {original_info['bitrate']/1000:.1f} kbps")

    print(
        f"    Size:        {human_size(original_size):<20} {human_size(new_size)}")

    # Space savings
    savings = original_size - new_size
    savings_pct = (savings / original_size * 100) if original_size > 0 else 0
    savings_str = f"{human_size(abs(savings))} ({abs(savings_pct):.1f}%)"

    if is_larger:
        print(
            f"    Space saved: {colorize('-' + savings_str + ' (larger)', Colors.MAGENTA)}")
    else:
        print(f"    Space saved: {colorize(savings_str, Colors.GREEN)}")

    # Encoding settings
    print(f"\n    {colorize('ENCODING SETTINGS:', Colors.CYAN)}")
    print("    Video codec:   H.265/HEVC")
    print("    Quality:       CRF 25")
    print("    Preset:        slower")
    print("    Resolution:    max 1080p")
    print("    Framerate:     24 fps")
    print("    Audio:         64k mono AAC")
    print("‚îÄ" * 50)


def transcode_video(input_file: Path, work_dir: Path, index: int, total: int,
                    file_logger: logging.Logger, console_logger: logging.Logger) -> Tuple[bool, Optional[str], bool, int, Optional[Path]]:
    """Transcode a single video file."""
    file_logger.info(
        f"Starting transcoding of file #{index}/{total}: {input_file.name}")
    console_logger.info(f"[{index}/{total}] ‚ñ∂Ô∏è  Starting transcoding")
    print(colorize(f"[{index}/{total}] ‚ñ∂Ô∏è  Starting transcoding", Colors.BLUE))

    try:
        # Verify input file
        valid, error = verify_input_file(input_file, file_logger)
        if not valid:
            error_msg = f"Invalid input file: {error}"
            file_logger.error(f"{error_msg} - {input_file}")
            console_logger.error(f"[{index}/{total}] ‚ùå {error_msg}")
            return False, error_msg, False, 0, None

        # Get original file info
        original_size = input_file.stat().st_size
        metadata = get_video_metadata(input_file)
        original_info = extract_video_info(metadata)

        # Display file info
        duration_str = f"{original_info['duration']/60:.2f} minutes" if original_info['duration'] > 0 else "Unknown"
        print(f"    Duration: {duration_str}")
        print(f"    Resolution: {original_info['width']}x{original_info['height']}, "
              f"Size: {human_size(original_size)}, Codec: {original_info['codec']}")

        # Create temporary output file
        temp_output = work_dir / \
            f"transcode_{int(time.time())}_{input_file.name}"
        work_dir.mkdir(parents=True, exist_ok=True)

        # Create and run ffmpeg command
        cmd = create_ffmpeg_command(input_file, temp_output)

        # Start process with proper error capture
        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )

        # Monitor progress
        returncode, file_created, error_output = monitor_progress(
            process, original_info['duration'], index, total, temp_output
        )

        if returncode != 0 or not file_created:
            error_msg = f"Transcoding failed with code {returncode}"
            if not file_created:
                error_msg += ", no output file created"

            file_logger.error(f"{error_msg} - {input_file}")
            file_logger.error(f"Error output: {error_output}")
            console_logger.error(f"[{index}/{total}] ‚ùå {error_msg}")

            # Clean up temp file
            if temp_output.exists():
                temp_output.unlink()

            return False, error_output or error_msg, False, 0, None

        # Check output file
        new_size = temp_output.stat().st_size
        is_larger = new_size >= original_size

        # Print summary
        print_transcoding_summary(
            index, total, original_info, original_size, new_size, is_larger)

        return True, None, is_larger, new_size, temp_output

    except Exception as e:
        error_msg = str(e)
        file_logger.error(f"Error transcoding {input_file}: {error_msg}")
        console_logger.error(f"[{index}/{total}] ‚ùå Error: {error_msg}")
        return False, error_msg, False, 0, None


def categorize_error(error_message: str) -> str:
    """Categorize error messages."""
    error_patterns = [
        ("No such file or directory", "File Access Error"),
        ("Permission denied", "Permission Error"),
        ("Invalid data found", "Corrupted Video Data"),
        ("Conversion failed", "Encoder Error"),
        ("Out of memory", "Memory Error"),
    ]

    if error_message:
        for pattern, category in error_patterns:
            if pattern in error_message:
                return category

    return "Other Error"


def write_file_lists(successful: List[str], larger: List[str],
                     failed: List[Tuple[str, str]], empty_dirs: List[Path]):
    """Write summary files."""
    # Successful files
    if successful:
        with open("successful_transcodes.txt", 'w') as f:
            f.write('\n'.join(successful))
        print(colorize(
            f"üìù Wrote {len(successful)} successful files to successful_transcodes.txt", Colors.GREEN))

    # Larger files
    if larger:
        with open("larger_transcodes.txt", 'w') as f:
            f.write('\n'.join(larger))
        print(colorize(
            f"üìù Wrote {len(larger)} larger files to larger_transcodes.txt", Colors.MAGENTA))

    # Failed files
    if failed or empty_dirs:
        with open("failed_transcodes.txt", 'w') as f:
            if failed:
                # Group by error category
                errors_by_category = {}
                for filename, error in failed:
                    category = categorize_error(error)
                    if category not in errors_by_category:
                        errors_by_category[category] = []
                    errors_by_category[category].append((filename, error))

                f.write(f"FAILED TRANSCODES BY ERROR CATEGORY\n")
                f.write(f"Total failed: {len(failed)}\n\n")

                for category, files in sorted(errors_by_category.items()):
                    f.write(f"{category.upper()} ({len(files)}):\n")
                    for filename, error in files:
                        condensed = error.replace('\n', ' ').strip()[:100]
                        f.write(f"- {filename} | {condensed}\n")
                    f.write("\n")

            if empty_dirs:
                f.write(
                    f"\nDIRECTORIES WITHOUT VIDEO FILES ({len(empty_dirs)}):\n")
                for dir_path in empty_dirs:
                    f.write(f"- {dir_path}\n")

        print(
            colorize(f"üìù Wrote failed files list to failed_transcodes.txt", Colors.YELLOW))


def print_final_summary(successful: int, larger: int, failed: int,
                        total_original: int, total_new: int,
                        start_time: float, log_file: str):
    """Print final batch summary."""
    elapsed = time.time() - start_time
    hours = int(elapsed / 3600)
    mins = int((elapsed % 3600) / 60)
    secs = int(elapsed % 60)

    print("\n" + "‚ïê" * 70)
    print(colorize("  BATCH TRANSCODE SUMMARY", Colors.BOLD + Colors.CYAN))
    print("‚ïê" * 70)

    print(colorize("\n  RESULTS", Colors.BOLD))
    print(f"  ‚úÖ Successfully transcoded (smaller): {successful} files")
    print(f"  üìä Successfully transcoded (larger): {larger} files")
    print(f"  ‚ùå Failed to transcode: {failed} files")

    print(colorize("\n  SPACE SAVINGS", Colors.BOLD))
    print(f"  üíæ Total original size: {human_size(total_original)}")
    print(f"  üíæ Total new size: {human_size(total_new)}")

    savings = total_original - total_new
    savings_pct = (savings / total_original * 100) if total_original > 0 else 0
    savings_text = f"  üîΩ Total space saved: {human_size(abs(savings))} ({abs(savings_pct):.1f}%)"
    print(colorize(savings_text, Colors.GREEN if savings > 0 else Colors.RED))

    print(colorize("\n  TIME STATISTICS", Colors.BOLD))
    print(f"  üïí Total processing time: {hours}h {mins}m {secs}s")

    if successful + larger > 0:
        avg_time = elapsed / (successful + larger)
        print(
            f"  üïí Average time per file: {int(avg_time/60)}m {int(avg_time % 60)}s")

    print(colorize("\n  FILE LOCATIONS", Colors.BOLD))
    print(f"  üìù Log file: {log_file}")
    print(f"  üìã Successful files list: successful_transcodes.txt")
    print(f"  üìã Larger output files list: larger_transcodes.txt")
    print(f"  üìã Failed files list: failed_transcodes.txt")
    print("‚ïê" * 70)


def main():
    # Parse arguments
    parser = argparse.ArgumentParser(description="Video Transcoder Script")
    parser.add_argument(
        "input_dir", help="Input directory containing video files")
    parser.add_argument("-s", "--success_dir", default="transcoded_success",
                        help="Output directory for successfully transcoded files")
    parser.add_argument("-e", "--error_dir", default="transcoded_error",
                        help="Output directory for files that failed transcoding")
    parser.add_argument("-l", "--larger_dir", default="transcoded_larger",
                        help="Output directory for transcoded files larger than original")
    parser.add_argument("-w", "--work_dir", default="work_in_progress",
                        help="Temporary directory for files being processed")
    parser.add_argument("-v", "--verbose", action="store_true",
                        help="Enable verbose logging")
    args = parser.parse_args()

    # Setup
    file_logger, console_logger, log_file = setup_logging()

    # Print header
    print("\n" + "‚ïê" * 70)
    print(colorize("  VIDEO TRANSCODER", Colors.BOLD + Colors.CYAN))
    print(colorize("  Optimized for small size and mobile viewing", Colors.CYAN))
    print("‚ïê" * 70 + "\n")

    # Verify ffmpeg is available
    try:
        subprocess.run(["ffmpeg", "-version"], capture_output=True, check=True)
        print(colorize("‚úÖ ffmpeg is available", Colors.GREEN))
    except (subprocess.SubprocessError, FileNotFoundError):
        print(colorize("‚ùå ffmpeg not found. Please install ffmpeg.", Colors.RED))
        sys.exit(1)

    # Setup directories
    input_dir = Path(args.input_dir)
    if not input_dir.is_dir():
        print(
            colorize(f"‚ùå Input directory not found: {input_dir}", Colors.RED))
        sys.exit(1)

    success_dir = Path(args.success_dir)
    error_dir = Path(args.error_dir)
    larger_dir = Path(args.larger_dir)
    work_dir = Path(args.work_dir)

    # Create directories
    for directory in [success_dir, error_dir, larger_dir, work_dir]:
        directory.mkdir(exist_ok=True)

    # Find video files
    print(colorize("üîç Searching for video files...", Colors.BLUE))
    video_files, empty_dirs = find_video_files(input_dir)

    if not video_files:
        print(colorize("‚ùå No video files found.", Colors.RED))
        if empty_dirs:
            print(colorize(
                f"üìÅ Found {len(empty_dirs)} directories without videos", Colors.YELLOW))
            write_file_lists([], [], [], empty_dirs)
        sys.exit(0)

    print(
        colorize(f"üìÅ Found {len(video_files)} video files to transcode", Colors.GREEN))
    if empty_dirs:
        print(colorize(
            f"üìÅ Found {len(empty_dirs)} directories without videos", Colors.YELLOW))

    # Clean work directory
    for file in work_dir.glob('*'):
        try:
            file.unlink()
        except OSError:
            pass

    # Initialize tracking
    start_time = time.time()
    successful_files = []
    larger_files = []
    failed_files = []
    total_original_size = 0
    total_new_size = 0

    print("\n" + "‚ïê" * 70)
    print(colorize("  STARTING BATCH TRANSCODING", Colors.BOLD + Colors.YELLOW))
    print("‚ïê" * 70)

    # Process each video
    for i, video_file in enumerate(video_files, 1):
        print(colorize(f"\n[{i}/{len(video_files)}] Processing {i/len(video_files)*100:.1f}% complete",
                       Colors.BOLD + Colors.BLUE))
        print("‚îÄ" * 50)

        # Get original size
        try:
            original_size = video_file.stat().st_size
            total_original_size += original_size
        except OSError:
            original_size = 0

        # Transcode
        success, error, is_larger, new_size, temp_output = transcode_video(
            video_file, work_dir, i, len(
                video_files), file_logger, console_logger
        )

        if success and temp_output:
            # Move to appropriate directory
            if is_larger:
                destination = larger_dir / video_file.name
                larger_files.append(video_file.name)
            else:
                destination = success_dir / video_file.name
                successful_files.append(video_file.name)

            try:
                shutil.move(str(temp_output), str(destination))
                total_new_size += new_size
                print(colorize(f"üîÑ Moved to {'larger' if is_larger else 'success'} directory",
                               Colors.MAGENTA if is_larger else Colors.GREEN))
            except OSError as e:
                failed_files.append((video_file.name, f"Move failed: {e}"))
                if temp_output.exists():
                    temp_output.unlink()
        else:
            # Copy original to error directory
            failed_files.append((video_file.name, error or "Unknown error"))
            try:
                shutil.copy2(video_file, error_dir / video_file.name)
                print(colorize("üìã Copied original to error directory", Colors.YELLOW))
            except OSError:
                pass

    # Write summary files
    write_file_lists(successful_files, larger_files, failed_files, empty_dirs)

    # Print final summary
    print_final_summary(
        len(successful_files), len(larger_files), len(failed_files),
        total_original_size, total_new_size, start_time, log_file
    )

    # Final logging
    file_logger.info(f"Batch complete: {len(successful_files)} successful, "
                     f"{len(larger_files)} larger, {len(failed_files)} failed")


if __name__ == "__main__":
    main()
