#!/usr/bin/env python3 -u
"""
Video Transcoder Script
This script recursively searches for video files and transcodes them using ffmpeg,
optimized for small size and mobile viewing.

Add the -u flag to the command line to use unbuffered output:
python3 -u transcode.py /path/to/videos
"""
import os
import sys
import subprocess
import argparse
import logging
import json
import time
import signal
import shutil
from pathlib import Path
from datetime import datetime

# Force unbuffered output
sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', buffering=1)
sys.stderr = os.fdopen(sys.stderr.fileno(), 'w', buffering=1)

# ANSI color codes for terminal output
class Colors:
    RESET = "\033[0m"
    BOLD = "\033[1m"
    RED = "\033[91m"
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    BLUE = "\033[94m"
    MAGENTA = "\033[95m"
    CYAN = "\033[96m"
    WHITE = "\033[97m"
    GREY = "\033[90m"

# Check if terminal supports colors
def supports_color():
    """Check if the terminal supports colors"""
    if os.name == 'nt':
        return False  # Simplified check for Windows
    
    if not hasattr(sys.stdout, 'isatty') or not sys.stdout.isatty():
        return False
    
    return True

USE_COLORS = supports_color()

# Color formatting function
def colorize(text, color, use_color=True):
    """Add color to text if supported"""
    if use_color and USE_COLORS:
        return f"{color}{text}{Colors.RESET}"
    return text

# Setup logging to both file and console
def setup_logging(verbose=False):
    log_file = f"transcode_log_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"
    
    # File logger (with all details)
    file_logger = logging.getLogger("file_logger")
    file_logger.setLevel(logging.DEBUG if verbose else logging.INFO)
    
    # Console logger (generic info only)
    console_logger = logging.getLogger("console_logger")  
    console_logger.setLevel(logging.INFO)
    
    # Create file handler with full details
    file_handler = logging.FileHandler(log_file)
    file_handler.setLevel(logging.DEBUG if verbose else logging.INFO)
    file_formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    file_handler.setFormatter(file_formatter)
    file_logger.addHandler(file_handler)
    
    # Create console handler
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.INFO)
    console_formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    console_handler.setFormatter(console_formatter)
    console_logger.addHandler(console_handler)
    
    # We'll return both loggers
    return file_logger, console_logger, log_file

# Categorize error messages
def categorize_error(error_message):
    # Define common error patterns and their categories
    error_categories = [
        ("No such file or directory", "File Access Error"),
        ("Permission denied", "Permission Error"),
        ("Error while filtering", "Filter Error"),
        ("Invalid data found", "Corrupted File"),
        ("Conversion failed", "Conversion Error"),
        ("Missing picture in access unit", "Corrupted Video Data"),
        ("Invalid NAL unit size", "Corrupted Video Data"),
        ("Error splitting the input into NAL units", "Corrupted Video Data"),
        ("Error setting preset/tune", "Codec Configuration Error"),
        ("Error opening encoder", "Encoder Error"),
        ("Hardware accelerator initialization failed", "Hardware Acceleration Error"),
        ("Out of memory", "Memory Error"),
        ("Unknown encoder", "Missing Codec"),
    ]
    
    # Check if error message contains any of the known patterns
    for pattern, category in error_categories:
        if pattern in error_message:
            return category
    
    # Default category for unrecognized errors
    return "Other Error"

# Find all video files in a directory and its subdirectories
def find_video_files(input_dir):
    # Convert input_dir to absolute path to ensure consistent path handling
    input_dir_abs = os.path.abspath(input_dir)
    
    video_extensions = ['.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm', '.m4v', '.3gp']
    video_files = []
    all_dirs = set()
    dirs_with_videos = set()
    
    for root, dirs, files in os.walk(input_dir):
        # Convert path to normalized absolute path
        abs_root = os.path.abspath(root)
        all_dirs.add(abs_root)
        
        has_video = False
        for file in files:
            if any(file.lower().endswith(ext) for ext in video_extensions):
                # Use Path for better handling of special characters
                video_path = Path(root) / file
                video_files.append(str(video_path))
                has_video = True
        
        if has_video:
            # Mark this directory as having videos
            dirs_with_videos.add(abs_root)
            
            # Also mark all parent directories up to the input directory
            current = abs_root
            while current != input_dir_abs and os.path.dirname(current) != current:
                parent = os.path.dirname(current)
                if parent:
                    dirs_with_videos.add(parent)
                    current = parent
                else:
                    break
    
    # Find directories without videos
    empty_dirs = all_dirs - dirs_with_videos
    
    # Sort directories for better readability
    empty_dirs = sorted(empty_dirs)
    
    return video_files, empty_dirs

# Get video file metadata using ffprobe
def get_video_metadata(video_path, file_logger):
    try:
        cmd = [
            "ffprobe",
            "-v", "quiet",
            "-print_format", "json",
            "-show_format",
            "-show_streams",
            video_path
        ]
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        return json.loads(result.stdout)
    except (subprocess.CalledProcessError, json.JSONDecodeError) as e:
        file_logger.warning(f"Failed to get metadata for {video_path}: {str(e)}")
        return None

# Extract video duration from metadata
def get_duration(metadata):
    if not metadata:
        return None
    
    # Try to get duration from format section
    if "format" in metadata and "duration" in metadata["format"]:
        try:
            return float(metadata["format"]["duration"])
        except (ValueError, TypeError):
            pass
    
    # If not found in format, try streams
    for stream in metadata.get("streams", []):
        if "duration" in stream:
            try:
                return float(stream["duration"])
            except (ValueError, TypeError):
                pass
    
    return None

# Convert HH:MM:SS.MS time format to seconds
def time_to_seconds(time_str):
    try:
        # Handle different time formats
        if '.' in time_str:  # Has milliseconds
            parts = time_str.split(':')
            if len(parts) == 3:  # HH:MM:SS.MS
                hours, minutes, seconds = parts
                seconds = float(seconds)
                return int(hours) * 3600 + int(minutes) * 60 + seconds
            elif len(parts) == 2:  # MM:SS.MS
                minutes, seconds = parts
                seconds = float(seconds)
                return int(minutes) * 60 + seconds
        else:  # No milliseconds
            parts = time_str.split(':')
            if len(parts) == 3:  # HH:MM:SS
                hours, minutes, seconds = parts
                return int(hours) * 3600 + int(minutes) * 60 + int(seconds)
            elif len(parts) == 2:  # MM:SS
                minutes, seconds = parts
                return int(minutes) * 60 + int(seconds)
        
        # If none of the above formats match, try direct conversion
        return float(time_str)
    except (ValueError, TypeError):
        return 0  # Return 0 on error

# Get human readable size
def human_size(bytes, units=[' bytes','KB','MB','GB','TB']):
    return str(bytes) + units[0] if bytes < 1024 else human_size(bytes>>10, units[1:])

# Function to extract video resolution from metadata
def get_resolution(metadata):
    if not metadata:
        return "unknown", "unknown"
    
    for stream in metadata.get("streams", []):
        if stream.get("codec_type") == "video":
            return stream.get("width", "unknown"), stream.get("height", "unknown")
    
    return "unknown", "unknown"

# Get video bitrate from metadata
def get_bitrate(metadata):
    if not metadata:
        return "unknown"
    
    if "format" in metadata and "bit_rate" in metadata["format"]:
        try:
            return int(metadata["format"]["bit_rate"])
        except (ValueError, TypeError):
            pass
    
    for stream in metadata.get("streams", []):
        if stream.get("codec_type") == "video" and "bit_rate" in stream:
            try:
                return int(stream["bit_rate"])
            except (ValueError, TypeError):
                pass
    
    return "unknown"

# Get audio details from metadata
def get_audio_details(metadata):
    if not metadata:
        return {"codec": "unknown", "channels": "unknown", "bitrate": "unknown"}
    
    for stream in metadata.get("streams", []):
        if stream.get("codec_type") == "audio":
            details = {
                "codec": stream.get("codec_name", "unknown"),
                "channels": stream.get("channels", "unknown"),
                "bitrate": stream.get("bit_rate", "unknown")
            }
            return details
    
    return {"codec": "none", "channels": "none", "bitrate": "none"}

# Get video codec from metadata
def get_video_codec(metadata):
    if not metadata:
        return "unknown"
    
    for stream in metadata.get("streams", []):
        if stream.get("codec_type") == "video":
            return stream.get("codec_name", "unknown")
    
    return "unknown"

# Simple progress monitoring for FFmpeg
def monitor_ffmpeg_progress(process, total_duration, file_index, total_files, output_file_path):
    """Monitor FFmpeg progress and print updates in place, checking file creation and growth"""
    start_time = time.time()
    last_update = start_time
    update_interval = 1  # seconds
    last_file_check = start_time
    file_check_interval = 5  # check file size every 5 seconds
    last_file_size = 0
    file_created = False
    no_growth_count = 0
    max_no_growth = 5  # Allow 5 checks (25 seconds) with no growth before warning
    
    # Get terminal width for proper formatting
    term_width = shutil.get_terminal_size().columns
    
    # Print initial message
    init_msg = colorize(f"[{file_index}/{total_files}] Starting encoding...", Colors.BLUE, USE_COLORS)
    print(init_msg, end="\r", flush=True)
    
    # Monitor the process while it's running
    while process.poll() is None:
        # Sleep briefly to avoid CPU spinning
        time.sleep(0.5)
        
        current_time = time.time()
        elapsed = current_time - start_time
        
        # Check if output file exists and is growing
        if current_time - last_file_check >= file_check_interval:
            last_file_check = current_time
            current_file_size = 0
            
            # Check if file exists and get size
            if os.path.exists(output_file_path):
                file_created = True
                try:
                    current_file_size = os.path.getsize(output_file_path)
                    
                    # Check if file is growing
                    if current_file_size == last_file_size and current_file_size > 0:
                        no_growth_count += 1
                    else:
                        no_growth_count = 0
                    
                    last_file_size = current_file_size
                except:
                    pass
            
            # If file hasn't been created after 30 seconds, show warning
            if not file_created and elapsed > 30:
                warning_msg = f"‚ö†Ô∏è  Warning: Output file not created yet after {int(elapsed)}s"
                print(f"\r{warning_msg}".ljust(term_width))
            
            # If file exists but hasn't grown for several checks, show warning
            if file_created and no_growth_count >= max_no_growth and current_file_size > 0:
                warning_msg = f"‚ö†Ô∏è  Warning: Output file size not changing ({human_size(current_file_size)})"
                print(f"\r{warning_msg}".ljust(term_width))
        
        # Only update display periodically
        if (current_time - last_update) >= update_interval:
            last_update = current_time
            
            # Get file size information
            current_file_size = 0
            file_status = "waiting for output file..."
            if os.path.exists(output_file_path):
                file_created = True
                try:
                    current_file_size = os.path.getsize(output_file_path)
                    file_status = f"output: {human_size(current_file_size)}"
                    if last_file_size > 0 and current_file_size > last_file_size:
                        growth_rate = (current_file_size - last_file_size) / file_check_interval
                        file_status += f" (+{human_size(growth_rate)}/s)"
                except:
                    file_status = "error reading file size"
            
            # Estimate progress if we know the duration
            if total_duration > 0:
                # Very rough progress estimate based on elapsed time and typical encoding speed
                rough_progress = min(95, (elapsed / (total_duration * 1.5)) * 100)
                
                # Format elapsed time
                elapsed_mins = int(elapsed / 60)
                elapsed_secs = int(elapsed % 60)
                
                # Calculate ETA
                if rough_progress > 0:
                    total_estimated_seconds = (elapsed / rough_progress) * 100
                    remaining_seconds = total_estimated_seconds - elapsed
                    eta_mins = int(remaining_seconds / 60)
                    eta_secs = int(remaining_seconds % 60)
                    eta_str = colorize(f"ETA: {eta_mins}m {eta_secs}s", Colors.CYAN, USE_COLORS)
                else:
                    eta_str = ""
                
                # Create a progress bar
                bar_length = min(20, term_width - 80)  # Shorter to make room for file info
                filled_length = int(bar_length * rough_progress / 100)
                
                # Color the progress bar
                if USE_COLORS:
                    # Choose color based on progress
                    if rough_progress < 33:
                        bar_color = Colors.RED
                    elif rough_progress < 66:
                        bar_color = Colors.YELLOW
                    else:
                        bar_color = Colors.GREEN
                        
                    bar = f"{bar_color}{'‚ñà' * filled_length}{Colors.GREY}{'‚ñë' * (bar_length - filled_length)}{Colors.RESET}"
                else:
                    bar = '‚ñà' * filled_length + '‚ñë' * (bar_length - filled_length)
                
                # Format the progress percentage
                progress_pct = colorize(f"{rough_progress:.1f}%", Colors.BOLD, USE_COLORS)
                
                # File status info with color
                file_info = ""
                if file_created:
                    file_color = Colors.GREEN
                else:
                    file_color = Colors.RED
                file_info = colorize(f"[{file_status}]", file_color, USE_COLORS)
                
                # Display progress with progress bar and file info
                progress_msg = f"[{file_index}/{total_files}] [{bar}] {progress_pct} | {elapsed_mins}m {elapsed_secs}s {file_info}"
                if eta_str:
                    progress_msg += f" | {eta_str}"
                
                # Make sure the line is long enough to overwrite previous line
                progress_msg = progress_msg.ljust(min(term_width, 100))
                
                # Print with carriage return to update in place
                print(f"\r{progress_msg}", end="", flush=True)
            else:
                # Just show elapsed time if we don't know duration
                elapsed_mins = int(elapsed / 60)
                elapsed_secs = int(elapsed % 60)
                file_info = colorize(f"[{file_status}]", Colors.CYAN if file_created else Colors.RED, USE_COLORS)
                progress_msg = f"[{file_index}/{total_files}] {colorize('Processing...', Colors.BLUE, USE_COLORS)} {elapsed_mins}m {elapsed_secs}s {file_info}"
                progress_msg = progress_msg.ljust(min(term_width, 100))
                print(f"\r{progress_msg}", end="", flush=True)
                
            # Force flush to ensure terminal updates
            sys.stdout.flush()
    
    # Print final message with newline when process completes
    total_elapsed = time.time() - start_time
    elapsed_mins = int(total_elapsed / 60)
    elapsed_secs = int(total_elapsed % 60)
    
    # Check final file status
    final_file_size = 0
    file_status = "file not created"
    if os.path.exists(output_file_path):
        try:
            final_file_size = os.path.getsize(output_file_path)
            file_status = f"output: {human_size(final_file_size)}"
        except:
            file_status = "error reading file size"
    
    # Final message with file info
    final_msg = colorize(f"[{file_index}/{total_files}] Encoding completed in {elapsed_mins}m {elapsed_secs}s", Colors.GREEN, USE_COLORS)
    final_msg += " " + colorize(f"[{file_status}]", Colors.GREEN if final_file_size > 0 else Colors.RED, USE_COLORS)
    final_msg = final_msg.ljust(min(term_width, 100))  # Make sure we overwrite the whole progress line
    print(final_msg)
    
    return process.returncode, final_file_size > 0

# Create a standard encoding command based on options
def create_encoding_command(input_path, output_path, crf=28, preset="slower", tune=None):
    # Base command with default options
    cmd = [
        "ffmpeg",
        "-hwaccel", "auto",  # Add hardware acceleration where available
        "-i", str(input_path),
        "-map", "0:v:0", "-map", "0:a:0?",
        "-c:v", "libx265",
        "-preset", preset,
        "-x265-params", "limit-refs=3:no-amp=1:rd=4:aq-mode=2:bframes=4",  # Enhanced x265 parameters
        "-crf", str(crf),
        "-g", "48",  # Keyframe every 2 seconds at 24fps - better mobile seeking
        # Only downscale if resolution is higher than 720p
        "-vf", "scale='min(1280,iw)':'min(720,ih)':force_original_aspect_ratio=decrease,setsar=1",
        "-r", "24",
        "-c:a", "aac", 
        "-b:a", "48k",  # Reduced from 64k - sufficient for dialogue
        "-ac", "1", 
        "-ar", "32000",  # Reduced from 44100 - sufficient for dialogue
        "-af", "loudnorm,bandpass=f=1500:width_type=h:width=200",  # Audio normalization and voice optimization
        "-pix_fmt", "yuv420p",
        "-profile:v", "main", "-level", "3.1",
        "-movflags", "+faststart",
        "-metadata", "title=", "-metadata", "comment=",
        "-threads", "0",  # Use all available CPU cores
        "-v", "warning",  # Reduce verbosity - only show warnings and errors
        str(output_path)
    ]
    
    # Add tune parameter if specified
    if tune:
        cmd.insert(cmd.index("-preset") + 2, "-tune")
        cmd.insert(cmd.index("-preset") + 3, tune)
    
    return cmd

# Get encoding settings summary
def get_encoding_settings_summary(cmd):
    # Extract key encoding parameters for display
    settings = {
        "codec": "H.265/HEVC",
        "preset": "slower",
        "crf": "28",
        "resolution": "max 720p",
        "framerate": "24 fps",
        "audio": "48k mono AAC"
    }
    
    # Try to get actual values from command
    for i, param in enumerate(cmd):
        if param == "-preset" and i+1 < len(cmd):
            settings["preset"] = cmd[i+1]
        elif param == "-crf" and i+1 < len(cmd):
            settings["crf"] = cmd[i+1]
        elif param == "-r" and i+1 < len(cmd):
            settings["framerate"] = f"{cmd[i+1]} fps"
        elif param == "-b:a" and i+1 < len(cmd):
            settings["audio"] = f"{cmd[i+1]} "
            if "-ac" in cmd:
                ac_idx = cmd.index("-ac") + 1
                if cmd[ac_idx] == "1":
                    settings["audio"] += "mono "
                elif cmd[ac_idx] == "2":
                    settings["audio"] += "stereo "
            settings["audio"] += "AAC"
    
    return settings

# Transcode a video file
def transcode_video(input_file, output_file, index, total, file_logger, console_logger):
    # Log with filename to file only
    file_logger.info(f"Starting transcoding of file #{index}/{total}: {os.path.basename(input_file)}")
    # Log to console without filename
    console_logger.info(f"[{index}/{total}] ‚ñ∂Ô∏è Starting transcoding")
    print(colorize(f"[{index}/{total}] ‚ñ∂Ô∏è Starting transcoding", Colors.BLUE, USE_COLORS))
    
    try:
        # Get original metadata and file size
        original_size = os.path.getsize(input_file)
        metadata = get_video_metadata(input_file, file_logger)
        orig_width, orig_height = get_resolution(metadata)
        orig_codec = get_video_codec(metadata)
        orig_bitrate = get_bitrate(metadata)
        orig_audio = get_audio_details(metadata)
        
        # Get the duration for percentage calculation
        duration_seconds = get_duration(metadata)
        if duration_seconds:
            duration_str = f"{duration_seconds/60:.2f} minutes"
            file_logger.info(f"Video duration: {duration_seconds:.2f} seconds")
            print(f"    Duration: {duration_str}")
        else:
            file_logger.warning("Could not determine video duration")
            print("    Duration: Unknown")
            duration_seconds = 0  # Fallback value
        
        # Log original video details for diagnostics
        original_details = f"Resolution: {orig_width}x{orig_height}"
        if orig_bitrate != "unknown":
            original_details += f", Bitrate: {orig_bitrate/1000:.1f} kbps"
        original_details += f", Size: {original_size/1024/1024:.2f} MB"
        original_details += f", Codec: {orig_codec}"
        
        file_logger.info(f"Original video specs: {original_details}")
        print(f"    {original_details}")
        
        # Use Path objects for better handling of special characters
        input_path = Path(input_file)
        output_path = Path(output_file)
        
        # Make sure the output directory exists
        output_dir = output_path.parent
        if not output_dir.exists():
            output_dir.mkdir(parents=True, exist_ok=True)
            file_logger.info(f"Created output directory: {output_dir}")
        
        # Check if we have write permissions to the output directory
        if not os.access(str(output_dir), os.W_OK):
            error_msg = f"No write permission to output directory: {output_dir}"
            file_logger.error(error_msg)
            console_logger.error(f"[{index}/{total}] ‚ùå Error: No write permission to output directory")
            print(colorize(f"[{index}/{total}] ‚ùå Error: No write permission to output directory", Colors.RED, USE_COLORS))
            return False, error_msg
        
        # Check if there's enough disk space (need at least original file size)
        try:
            free_space = shutil.disk_usage(str(output_dir)).free
            if free_space < original_size:
                error_msg = f"Not enough disk space. Need {human_size(original_size)}, have {human_size(free_space)}"
                file_logger.error(error_msg)
                console_logger.error(f"[{index}/{total}] ‚ùå Error: Not enough disk space")
                print(colorize(f"[{index}/{total}] ‚ùå Error: Not enough disk space. Need {human_size(original_size)}, have {human_size(free_space)}", Colors.RED, USE_COLORS))
                return False, error_msg
        except:
            # If we can't check disk space, log but continue
            file_logger.warning("Could not check free disk space")
        
        # Create encoding command
        cmd = create_encoding_command(input_path, output_path)
        
        # Log the ffmpeg command for diagnostics (without the actual filename)
        cmd_log = ' '.join(cmd)
        cmd_log = cmd_log.replace(str(input_path), "INPUT_FILE").replace(str(output_path), "OUTPUT_FILE")
        file_logger.info(f"Running ffmpeg command: {cmd_log}")
        
        # Set a timeout for ffmpeg process (based on video duration, minimum 10 minutes)
        timeout_seconds = max(600, int(duration_seconds * 5)) if duration_seconds > 0 else 3600
        
        # Start the ffmpeg process
        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1,
            preexec_fn=os.setsid  # Make the process a process group leader
        )
        
        # Set up a watchdog timer for the process
        start_time = time.time()
        
        # Monitor progress
        return_code, file_created = monitor_ffmpeg_progress(process, duration_seconds, index, total, output_file)
        
        # Check if process took too long
        elapsed_time = time.time() - start_time
        if elapsed_time > timeout_seconds:
            try:
                os.killpg(os.getpgid(process.pid), signal.SIGTERM)
                time.sleep(1)  # Give it a second to terminate gracefully
                if process.poll() is None:  # If still running
                    os.killpg(os.getpgid(process.pid), signal.SIGKILL)  # Force kill
            except:
                pass
            
            error_msg = f"Process timed out after {int(elapsed_time)} seconds (timeout: {timeout_seconds}s)"
            file_logger.error(error_msg)
            console_logger.error(f"[{index}/{total}] ‚ùå Error: Process timed out")
            print(colorize(f"[{index}/{total}] ‚ùå Error: Process timed out after {int(elapsed_time)} seconds", Colors.RED, USE_COLORS))
            return False, error_msg
        
        # Collect any error output
        error_output = process.stderr.read() if process.stderr else ""
        
        if return_code != 0 or not file_created:
            # Log the error output
            file_logger.error(f"Transcoding failed for file #{index}: {os.path.basename(input_file)}")
            file_logger.error(f"FFmpeg return code: {return_code}")
            file_logger.error(f"File created: {file_created}")
            file_logger.error(f"FFmpeg error output: {error_output}")
            
            # Log sanitized error message to console
            error_msg = f"Transcoding failed with code {return_code}"
            if not file_created:
                error_msg += ", no output file was created"
            
            console_logger.error(f"[{index}/{total}] ‚ùå {error_msg}")
            print(colorize(f"[{index}/{total}] ‚ùå {error_msg}", Colors.RED, USE_COLORS))
            
            # Show error summary
            error_lines = error_output.splitlines()
            if error_lines:
                print(colorize("    Error details (last 5 lines):", Colors.RED, USE_COLORS))
                for line in error_lines[-5:]:
                    # Skip progress info in the error summary
                    if not line.strip().startswith("frame="):
                        print(f"    {line}")
            
            # Comprehensive error summary
            error_category = categorize_error(error_output)
            print(colorize(f"\n    Error Category: {error_category}", Colors.RED, USE_COLORS))
            print(colorize(f"    Original file has been copied to the error directory.", Colors.YELLOW, USE_COLORS))
            
            # Check if the output file exists but is empty/small
            if os.path.exists(output_file):
                try:
                    output_size = os.path.getsize(output_file)
                    if output_size < 10000:  # Less than 10KB
                        print(colorize(f"    Output file exists but is too small ({human_size(output_size)})", Colors.RED, USE_COLORS))
                except:
                    pass
            
            return False, error_output
        
        # Get new file size and calculate savings
        new_size = os.path.getsize(output_file)
        savings_bytes = original_size - new_size
        savings_percent = (savings_bytes / original_size) * 100 if original_size > 0 else 0
        
        # Verify the file is not corrupt by checking its size and getting metadata
        if new_size < 10000:  # Less than 10KB
            error_msg = f"Output file is too small ({human_size(new_size)}), likely corrupt"
            file_logger.error(error_msg)
            console_logger.error(f"[{index}/{total}] ‚ùå Error: Output file too small")
            print(colorize(f"[{index}/{total}] ‚ùå Error: Output file is suspiciously small ({human_size(new_size)})", Colors.RED, USE_COLORS))
            return False, error_msg
        
        # Get new metadata
        new_metadata = get_video_metadata(output_file, file_logger)
        if not new_metadata:
            error_msg = "Could not read metadata from output file, may be corrupt"
            file_logger.error(error_msg)
            console_logger.error(f"[{index}/{total}] ‚ùå Error: Cannot read output file metadata")
            print(colorize(f"[{index}/{total}] ‚ùå Error: Cannot read metadata from output file", Colors.RED, USE_COLORS))
            return False, error_msg
        
        # Extract information from new metadata
        new_width, new_height = get_resolution(new_metadata)
        new_bitrate = get_bitrate(new_metadata)
        new_audio = get_audio_details(new_metadata)
        
        # Log the results (full file name in log file only)
        file_logger.info(f"Completed file #{index}/{total}: {os.path.basename(input_file)}")
        file_logger.info(f"  Original resolution: {orig_width}x{orig_height}, New resolution: {new_width}x{new_height}")
        file_logger.info(f"  Original size: {original_size/1024/1024:.2f} MB, New size: {new_size/1024/1024:.2f} MB")
        file_logger.info(f"  Space saved: {savings_bytes/1024/1024:.2f} MB ({savings_percent:.2f}%)")
        
        # Console output - comprehensive summary
        print(colorize(f"[{index}/{total}] ‚úÖ Transcoding completed successfully", Colors.GREEN, USE_COLORS))
        
        # Create a summary box
        print("\n" + "‚îÄ" * 50)
        print(colorize("    TRANSCODING SUMMARY", Colors.BOLD + Colors.CYAN, USE_COLORS))
        print("‚îÄ" * 50)
        
        # File information
        print(f"    File: {colorize('#'+str(index), Colors.BOLD, USE_COLORS)} of {total}")
        
        # Before/After comparison table
        print("\n    " + colorize("BEFORE:", Colors.YELLOW, USE_COLORS) + " " * 18 + colorize("AFTER:", Colors.GREEN, USE_COLORS))
        print(f"    Resolution:  {orig_width}x{orig_height}" + " " * (14 - len(f"{orig_width}x{orig_height}")) + f"{new_width}x{new_height}")
        
        # Bitrate comparison
        orig_bitrate_str = f"{orig_bitrate/1000:.1f} kbps" if orig_bitrate != "unknown" else "unknown"
        new_bitrate_str = f"{new_bitrate/1000:.1f} kbps" if new_bitrate != "unknown" else "unknown"
        print(f"    Bitrate:     {orig_bitrate_str}" + " " * (14 - len(orig_bitrate_str)) + f"{new_bitrate_str}")
        
        # Size comparison with visual indicator
        orig_size_str = f"{original_size/1024/1024:.2f} MB"
        new_size_str = f"{new_size/1024/1024:.2f} MB"
        print(f"    Size:        {orig_size_str}" + " " * (14 - len(orig_size_str)) + f"{new_size_str}")
        
        # Space savings
        savings_str = f"{savings_bytes/1024/1024:.2f} MB ({savings_percent:.1f}%)"
        print(f"    Space saved: {colorize(savings_str, Colors.GREEN if savings_percent > 0 else Colors.RED, USE_COLORS)}")
        
        # Encoding settings used
        print("\n    " + colorize("ENCODING SETTINGS:", Colors.CYAN, USE_COLORS))
        print(f"    Video codec:   {encoding_settings['codec']}")
        print(f"    Quality:       CRF {encoding_settings['crf']}")
        print(f"    Preset:        {encoding_settings['preset']}")
        print(f"    Resolution:    {encoding_settings['resolution']}")
        print(f"    Framerate:     {encoding_settings['framerate']}")
        print(f"    Audio:         {encoding_settings['audio']}")
        print("‚îÄ" * 50)
        
        return True, None
    
    except Exception as e:
        # Log error with filename to file only
        error_message = str(e)
        file_logger.error(f"Error transcoding file #{index}: {os.path.basename(input_file)} - {error_message}")
        # Log error to console without filename
        console_logger.error(f"[{index}/{total}] ‚ùå Error: {error_message}")
        print(colorize(f"[{index}/{total}] ‚ùå Error: {error_message}", Colors.RED, USE_COLORS))
        
        # Get stack trace for debugging
        import traceback
        stack_trace = traceback.format_exc()
        file_logger.error(f"Stack trace: {stack_trace}")
        
        return False, error_message

def main():
    # Parse command line arguments
    parser = argparse.ArgumentParser(description="Video Transcoder Script")
    parser.add_argument("input_dir", help="Input directory containing video files to transcode")
    parser.add_argument("-s", "--success_dir", help="Output directory for successfully transcoded files", default="transcoded_success")
    parser.add_argument("-e", "--error_dir", help="Output directory for files that failed transcoding", default="transcoded_error")
    parser.add_argument("-w", "--work_dir", help="Temporary directory for files being processed", default="work_in_progress")
    parser.add_argument("-v", "--verbose", help="Enable verbose logging", action="store_true")
    parser.add_argument("-t", "--timeout", type=int, help="Maximum seconds to spend on a single file (default: auto based on duration)", default=0)
    args = parser.parse_args()
    
    # Setup logging
    file_logger, console_logger, log_file = setup_logging(args.verbose)
    
    # Print header
    print("\n" + "‚ïê" * 70)
    print(colorize("  VIDEO TRANSCODER", Colors.BOLD + Colors.CYAN, USE_COLORS))
    print(colorize("  Optimized for small size and mobile viewing", Colors.CYAN, USE_COLORS))
    print("‚ïê" * 70 + "\n")
    
    # Check if input directory exists
    if not os.path.isdir(args.input_dir):
        file_logger.error(f"Input directory does not exist: {args.input_dir}")
        console_logger.error(f"Input directory does not exist: {args.input_dir}")
        print(colorize("‚ùå Error: Input directory not found", Colors.RED, USE_COLORS))
        sys.exit(1)
    
    # Create output directories if they don't exist
    success_dir = Path(args.success_dir)
    error_dir = Path(args.error_dir)
    work_dir = Path(args.work_dir)
    success_dir.mkdir(exist_ok=True)
    error_dir.mkdir(exist_ok=True)
    work_dir.mkdir(exist_ok=True)
    
    # Check write permissions for all directories
    for dir_path, dir_name in [(success_dir, "success"), (error_dir, "error"), (work_dir, "work")]:
        if not os.access(str(dir_path), os.W_OK):
            print(colorize(f"‚ùå Error: No write permission to {dir_name} directory: {dir_path}", Colors.RED, USE_COLORS))
            sys.exit(1)
    
    # Files to track successful and failed transcodes
    success_list_file = "successful_transcodes.txt"
    failed_list_file = "failed_transcodes.txt"
    successful_files = []
    failed_files = []  # Will now store tuples of (filename, error_message)
    
    # Setup for batch processing statistics
    start_time = time.time()
    original_total_size = 0
    new_total_size = 0
    
    # Find all video files in the input directory, and directories without videos
    file_logger.info(f"Searching for video files in {args.input_dir}")
    console_logger.info(f"Searching for video files in {args.input_dir}")
    print(colorize("üîç Searching for video files...", Colors.BLUE, USE_COLORS))
    video_files, empty_dirs = find_video_files(args.input_dir)
    
    if not video_files:
        file_logger.warning("No video files found.")
        console_logger.warning("No video files found.")
        print(colorize("‚ùå No video files found in the specified directory.", Colors.RED, USE_COLORS))
        
        # If we found empty directories, still report those
        if empty_dirs:
            print(colorize(f"üìÅ Found {len(empty_dirs)} directories without video files:", Colors.YELLOW, USE_COLORS))
            for empty_dir in empty_dirs:
                print(f"    - {empty_dir}")
            
            # Write empty directories to failed list
            try:
                with open(failed_list_file, 'w', encoding='utf-8') as f:
                    f.write("DIRECTORIES WITHOUT VIDEO FILES:\n")
                    for empty_dir in empty_dirs:
                        f.write(f"{empty_dir}\n")
                print(colorize(f"üìù Wrote list of {len(empty_dirs)} empty directories to {failed_list_file}", Colors.GREY, USE_COLORS))
            except Exception as e:
                print(colorize(f"‚ùå Failed to write empty directories list: {str(e)}", Colors.RED, USE_COLORS))
        
        sys.exit(0)
    
    file_logger.info(f"Found {len(video_files)} video files to transcode")
    file_logger.info(f"Log file: {log_file}")
    console_logger.info(f"Found {len(video_files)} video files to transcode")
    console_logger.info(f"Log file: {log_file}")
    
    # Check if any leftover files exist in the work directory
    leftover_files = list(work_dir.glob('*'))
    if leftover_files:
        print(colorize(f"‚ö†Ô∏è  Found {len(leftover_files)} leftover files in work directory", Colors.YELLOW, USE_COLORS))
        print(colorize("    These may be from a previous interrupted run. They will be cleaned up.", Colors.YELLOW, USE_COLORS))
        
        # Clean up leftover files
        for leftover in leftover_files:
            try:
                leftover.unlink()
                file_logger.info(f"Removed leftover file from work directory: {leftover.name}")
            except Exception as e:
                file_logger.error(f"Failed to remove leftover file from work directory: {leftover.name} - {str(e)}")
                print(colorize(f"    ‚ùå Could not remove {leftover.name}: {str(e)}", Colors.RED, USE_COLORS))
    
    # Check disk space
    try:
        total_input_size = sum(os.path.getsize(f) for f in video_files)
        work_free_space = shutil.disk_usage(str(work_dir)).free
        success_free_space = shutil.disk_usage(str(success_dir)).free
        
        if work_free_space < total_input_size * 0.3:  # Need at least 30% of total input size
            print(colorize(f"‚ö†Ô∏è  Work directory has limited free space: {human_size(work_free_space)}", Colors.YELLOW, USE_COLORS))
            print(colorize(f"    Total input size: {human_size(total_input_size)}", Colors.YELLOW, USE_COLORS))
        
        if success_free_space < total_input_size * 0.3:  # Need at least 30% of total input size
            print(colorize(f"‚ö†Ô∏è  Success directory has limited free space: {human_size(success_free_space)}", Colors.YELLOW, USE_COLORS))
            print(colorize(f"    Total input size: {human_size(total_input_size)}", Colors.YELLOW, USE_COLORS))
    except:
        pass
    
    print(colorize(f"üìÅ Found {len(video_files)} video files to transcode", Colors.GREEN, USE_COLORS))
    if empty_dirs:
        print(colorize(f"üìÅ Found {len(empty_dirs)} directories without video files", Colors.YELLOW, USE_COLORS))
    print(colorize(f"üìù Log file: {log_file}", Colors.GREY, USE_COLORS))
    print(colorize(f"‚úÖ Success directory: {success_dir}", Colors.GREEN, USE_COLORS))
    print(colorize(f"‚ùå Error directory: {error_dir}", Colors.RED, USE_COLORS))
    print(colorize(f"üîÑ Work directory: {work_dir}", Colors.BLUE, USE_COLORS))
    
    # Divider before starting transcoding
    print("\n" + "‚ïê" * 70)
    print(colorize("  STARTING BATCH TRANSCODING", Colors.BOLD + Colors.YELLOW, USE_COLORS))
    print("‚ïê" * 70)
    
    # Transcode each video file
    successful = 0
    failed = 0
    total_original_size = 0
    total_new_size = 0
    
    for i, video_file in enumerate(video_files, 1):
        # Create output filenames (using work directory for in-progress files)
        basename = os.path.basename(video_file)
        work_output_file = work_dir / basename
        success_output_file = success_dir / basename
        error_output_file = error_dir / basename
        
        # Print file separator
        print(colorize(f"\n[{i}/{len(video_files)}] Processing {i/len(video_files)*100:.1f}% complete", 
                   Colors.BOLD + Colors.BLUE, USE_COLORS))
        print("‚îÄ" * 50)
        
        # Get original size for total calculation
        try:
            original_size = os.path.getsize(video_file)
            total_original_size += original_size
        except Exception as e:
            file_logger.error(f"Could not get file size for {video_file}: {str(e)}")
            print(colorize(f"‚ö†Ô∏è  Warning: Could not get file size", Colors.YELLOW, USE_COLORS))
            original_size = 0
        
        # Transcode the video to the work directory
        success, error_message = transcode_video(video_file, str(work_output_file), i, len(video_files), file_logger, console_logger)
        
        if success:
            # Move the file from work directory to success directory
            try:
                # Get size of the transcoded file before moving
                if os.path.exists(work_output_file):
                    new_size = os.path.getsize(work_output_file)
                    total_new_size += new_size
                    
                    # Use shutil.move for atomic file operations
                    shutil.move(str(work_output_file), str(success_output_file))
                    file_logger.info(f"Moved transcoded file from work directory to success directory: {basename}")
                    console_logger.info(f"Moved file #{i} to success directory")
                    print(colorize(f"üîÑ Moved transcoded file to success directory", Colors.GREEN, USE_COLORS))
                    
                    successful += 1
                    successful_files.append(basename)
                else:
                    # This shouldn't happen since we check in transcode_video, but just in case
                    error_msg = "Output file not found in work directory after successful transcode"
                    file_logger.error(error_msg)
                    console_logger.error(f"[{i}/{len(video_files)}] ‚ùå Error: {error_msg}")
                    print(colorize(f"‚ùå Error: Output file not found after transcoding", Colors.RED, USE_COLORS))
                    
                    failed += 1
                    failed_files.append((basename, error_msg))
            except Exception as e:
                # If move fails, consider it a failed transcode
                file_logger.error(f"Failed to move file from work to success directory: {basename} - {str(e)}")
                console_logger.error(f"Failed to move file #{i} to success directory")
                print(colorize(f"‚ùå Failed to move file to success directory: {str(e)}", Colors.RED, USE_COLORS))
                
                # Try to clean up the work file
                try:
                    if os.path.exists(work_output_file):
                        os.unlink(work_output_file)
                except:
                    pass
                
                # Count as a failure and copy original to error directory
                failed += 1
                failed_files.append((basename, f"Failed to move transcoded file: {str(e)}"))
                
                # Copy the original file to the error directory
                try:
                    shutil.copy2(video_file, str(error_output_file))
                    file_logger.info(f"Copied original file to error directory after move failure: {basename}")
                    print(colorize(f"üìã Copied original file to error directory", Colors.YELLOW, USE_COLORS))
                except Exception as copy_err:
                    file_logger.error(f"Failed to copy file to error directory: {basename} - {str(copy_err)}")
                    print(colorize(f"‚ùå Failed to copy file to error directory: {str(copy_err)}", Colors.RED, USE_COLORS))
        else:
            # For failed transcodes
            failed += 1
            failed_files.append((basename, error_message or "Unknown error"))
            
            # Clean up any partial file in the work directory
            try:
                if os.path.exists(work_output_file):
                    os.unlink(work_output_file)
                    file_logger.info(f"Removed partial file from work directory: {basename}")
            except Exception as e:
                file_logger.error(f"Failed to remove partial file from work directory: {basename} - {str(e)}")
            
            # Copy the original file to the error directory
            try:
                shutil.copy2(video_file, str(error_output_file))
                file_logger.info(f"Copied original file to error directory: {basename}")
                console_logger.info(f"Copied file #{i} to error directory")
                print(colorize(f"üìã Copied original file to error directory", Colors.YELLOW, USE_COLORS))
            except Exception as e:
                file_logger.error(f"Failed to copy file to error directory: {basename} - {str(e)}")
                console_logger.error(f"Failed to copy file #{i} to error directory")
                print(colorize(f"‚ùå Failed to copy file to error directory: {str(e)}", Colors.RED, USE_COLORS))
    
    # Clean up any leftover files in the work directory
    try:
        work_files = list(work_dir.glob('*'))
        if work_files:
            file_logger.warning(f"Found {len(work_files)} leftover files in work directory")
            print(colorize(f"‚ö†Ô∏è  Found {len(work_files)} leftover files in work directory", Colors.YELLOW, USE_COLORS))
            for work_file in work_files:
                try:
                    work_file.unlink()
                    file_logger.info(f"Removed leftover file from work directory: {work_file.name}")
                except Exception as e:
                    file_logger.error(f"Failed to remove leftover file from work directory: {work_file.name} - {str(e)}")
    except Exception as e:
        file_logger.error(f"Failed to clean up work directory: {str(e)}")
    
    # Calculate batch statistics
    batch_end_time = time.time()
    batch_elapsed = batch_end_time - start_time
    batch_hours = int(batch_elapsed / 3600)
    batch_mins = int((batch_elapsed % 3600) / 60)
    batch_secs = int(batch_elapsed % 60)
    
    # Write successful and failed files to their respective lists
    try:
        with open(success_list_file, 'w', encoding='utf-8') as f:
            f.write('\n'.join(successful_files))
        file_logger.info(f"Wrote list of {len(successful_files)} successful files to {success_list_file}")
        console_logger.info(f"Wrote list of {successful} successful files to file")
        print(colorize(f"üìù Wrote list of {successful} successful files to {success_list_file}", Colors.GREEN, USE_COLORS))
    except Exception as e:
        file_logger.error(f"Failed to write successful files list: {str(e)}")
        console_logger.error("Failed to write successful files list")
        print(colorize(f"‚ùå Failed to write successful files list: {str(e)}", Colors.RED, USE_COLORS))
    
    # Group failed files by error category
    if failed_files:
        try:
            errors_by_category = {}
            
            # Group files by error category
            for filename, error_message in failed_files:
                category = categorize_error(error_message)
                if category not in errors_by_category:
                    errors_by_category[category] = []
                errors_by_category[category].append((filename, error_message))
            
            # Write the categorized failed files
            with open(failed_list_file, 'w', encoding='utf-8') as f:
                f.write(f"FAILED TRANSCODES BY ERROR CATEGORY\n")
                f.write(f"Total failed: {len(failed_files)}\n\n")
                
                # Write empty directories first if any
                if empty_dirs:
                    f.write(f"DIRECTORIES WITHOUT VIDEO FILES ({len(empty_dirs)}):\n")
                    for empty_dir in empty_dirs:
                        f.write(f"- {empty_dir}\n")
                    f.write("\n")
                
                # Write each error category
                for category, files in sorted(errors_by_category.items()):
                    f.write(f"{category.upper()} ({len(files)}):\n")
                    for filename, error_msg in files:
                        # Write the filename and a condensed error message
                        condensed_error = error_msg.replace('\n', ' ').strip()
                        if len(condensed_error) > 100:
                            condensed_error = condensed_error[:97] + "..."
                        f.write(f"- {filename} | {condensed_error}\n")
                    f.write("\n")
            
            file_logger.info(f"Wrote list of {len(failed_files)} failed files (in {len(errors_by_category)} categories) to {failed_list_file}")
            console_logger.info(f"Wrote list of {failed} failed files to file")
            print(colorize(f"üìù Wrote list of {failed} failed files (in {len(errors_by_category)} categories) to {failed_list_file}", Colors.YELLOW, USE_COLORS))
            
            # Print summary of errors by category
            print(colorize("\nFailed files by category:", Colors.YELLOW, USE_COLORS))
            for category, files in sorted(errors_by_category.items()):
                print(f"  ‚Ä¢ {category}: {len(files)} files")
            
        except Exception as e:
            file_logger.error(f"Failed to write failed files list: {str(e)}")
            console_logger.error("Failed to write failed files list")
            print(colorize(f"‚ùå Failed to write failed files list: {str(e)}", Colors.RED, USE_COLORS))
    elif empty_dirs:
        # Only empty directories to report
        try:
            with open(failed_list_file, 'w', encoding='utf-8') as f:
                f.write(f"DIRECTORIES WITHOUT VIDEO FILES ({len(empty_dirs)}):\n")
                for empty_dir in empty_dirs:
                    f.write(f"- {empty_dir}\n")
            print(colorize(f"üìù Wrote list of {len(empty_dirs)} empty directories to {failed_list_file}", Colors.YELLOW, USE_COLORS))
        except Exception as e:
            print(colorize(f"‚ùå Failed to write empty directories list: {str(e)}", Colors.RED, USE_COLORS))
    
    # Calculate total savings
    total_savings = total_original_size - total_new_size
    savings_percent = (total_savings / total_original_size) * 100 if total_original_size > 0 else 0
    
    # Calculate average time per file
    avg_time_per_file = batch_elapsed / max(1, successful) if successful > 0 else 0
    avg_mins = int(avg_time_per_file / 60)
    avg_secs = int(avg_time_per_file % 60)
    
    # Print summary with some visual enhancements
    print("\n" + "‚ïê" * 70)
    print(colorize("  BATCH TRANSCODE SUMMARY", Colors.BOLD + Colors.CYAN, USE_COLORS))
    print("‚ïê" * 70)
    
    # Results table
    print(colorize("\n  RESULTS", Colors.BOLD, USE_COLORS))
    print(f"  ‚úÖ Successfully transcoded: {successful} files")
    print(f"  ‚ùå Failed to transcode: {failed} files")
    if empty_dirs:
        print(f"  üìÅ Directories without videos: {len(empty_dirs)}")
    
    # Space savings table
    print(colorize("\n  SPACE SAVINGS", Colors.BOLD, USE_COLORS))
    print(f"  üíæ Total original size: {human_size(total_original_size)}")
    print(f"  üíæ Total new size: {human_size(total_new_size)}")
    savings_text = f"  üîΩ Total space saved: {human_size(total_savings)} ({savings_percent:.1f}%)"
    if savings_percent > 0:
        print(colorize(savings_text, Colors.GREEN, USE_COLORS))
    else:
        print(colorize(savings_text, Colors.RED, USE_COLORS))
    
    # Time stats table
    print(colorize("\n  TIME STATISTICS", Colors.BOLD, USE_COLORS))
    print(f"  üïí Total processing time: {batch_hours}h {batch_mins}m {batch_secs}s")
    if successful > 0:
        print(f"  üïí Average time per file: {avg_mins}m {avg_secs}s")
    
    # File locations
    print(colorize("\n  FILE LOCATIONS", Colors.BOLD, USE_COLORS))
    print(f"  üìù Log file: {log_file}")
    print(f"  üìã Successful files list: {success_list_file}")
    print(f"  üìã Failed files list: {failed_list_file}")
    print("‚ïê" * 70)
    
    # Also log the summary details
    file_logger.info(f"Transcoding completed. {successful} successful, {failed} failed.")
    file_logger.info(f"Total original size: {total_original_size/1024/1024:.2f} MB")
    file_logger.info(f"Total new size: {total_new_size/1024/1024:.2f} MB")
    file_logger.info(f"Total space saved: {total_savings/1024/1024:.2f} MB ({savings_percent:.2f}%)")
    file_logger.info(f"Total processing time: {batch_hours}h {batch_mins}m {batch_secs}s")
    file_logger.info(f"Successful files list: {success_list_file}")
    file_logger.info(f"Failed files list: {failed_list_file}")

if __name__ == "__main__":
    main()
